<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-About BitcoinZK/Technical Foundations" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.1">
<title data-rh="true">Technical Foundations | BitcoinZK Docs</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://docs.bitcoinzk.io/About BitcoinZK/Technical Foundations"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Technical Foundations | BitcoinZK Docs"><meta data-rh="true" name="description" content="Zero-knowledge"><meta data-rh="true" property="og:description" content="Zero-knowledge"><link data-rh="true" rel="icon" href="/img/logo-t.svg"><link data-rh="true" rel="canonical" href="https://docs.bitcoinzk.io/About BitcoinZK/Technical Foundations"><link data-rh="true" rel="alternate" href="https://docs.bitcoinzk.io/About BitcoinZK/Technical Foundations" hreflang="en"><link data-rh="true" rel="alternate" href="https://docs.bitcoinzk.io/About BitcoinZK/Technical Foundations" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.c5a2995c.css">
<script src="/assets/js/runtime~main.d5d7ba70.js" defer="defer"></script>
<script src="/assets/js/main.91bf182e.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="BitcoinZK Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="BitcoinZK Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently dark mode)" aria-label="Switch between dark and light mode (currently dark mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/">Background</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/About BitcoinZK/">About BitcoinZK</a><button aria-label="Collapse sidebar category &#x27;About BitcoinZK&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/About BitcoinZK/Technical Foundations">Technical Foundations</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/About BitcoinZK/BitcoinZK Architecture">BitcoinZK Architecture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/About BitcoinZK/ZKBridge">ZKBridge</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/Build on BitcoinZK/BTC Connect">Build on BitcoinZK</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/Governance Token/">Governance Token</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/About BitcoinZK/"><span itemprop="name">About BitcoinZK</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Technical Foundations</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Technical Foundations</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="zero-knowledge">Zero-knowledge<a href="#zero-knowledge" class="hash-link" aria-label="Direct link to Zero-knowledge" title="Direct link to Zero-knowledge">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="what-and-why">What and Why<a href="#what-and-why" class="hash-link" aria-label="Direct link to What and Why" title="Direct link to What and Why">​</a></h3>
<p>ZK is a cryptographic method that allows one party (the prover) to prove to another party (the verifier) that a statement is true without revealing any additional information other than the truthfulness of the statement.</p>
<p>Constructing ZK generally requires satisfying three important properties:</p>
<ul>
<li>
<p><strong>Completeness</strong>: The prover indeed possesses the answer to a certain assertion and can convince the verifier.</p>
</li>
<li>
<p><strong>Soundness</strong>: If the prover does not possess the answer to the assertion, it cannot convince the verifier.</p>
</li>
<li>
<p><strong>Zero-knowledge</strong>: The verifier knows only the result of the assertion judgment and is ignorant of any other information.</p>
</li>
</ul>
<p>In the field of cryptography, ZK has become a relatively mature and widely accepted pattern, especially in the Layer-2 scenario, where Layer-2 needs to prove to Layer-1 that its execution is correct. We try not to delve too much into the technical details of ZK (we don&#x27;t seek to bring any innovation at the level of ZK algorithms or mathematics), but rather focus on the advantages of ZK and the reasons for using ZK to build this Bitcoin Layer-2 solution.</p>
<p>In theory, Layer-2s can submit all transaction data to Layer-1 and have Layer-1 execute all the transactions for verification. However, this approach consumes a lot of resources. The market has widely accepted the verification scheme called Fraud Proof (the OptimismLayer-2 style) to save resources consumed by on-chain verification. Here, the advantages of ZK come into play because ZK proofs are succinct, meaning that verifiers only need to perform fewer computations (much less than generating ZK proofs) to complete the verification. This is perfect for Layer-2 solutions because Layer-2 exists to solve the performance limitations and resource shortages (mainly execution resources) of Layer-1. Thus, making Layer-2s spend more resources to generate proofs while releasing Layer-1 verifiers with much fewer resources to verify a Validity Proof becomes a win-win situation.</p>
<p>The difference between Bitcoin and Ethereum is that Bitcoin shows more limitations in its ability to execute smart contracts, which causes its inability to natively verify transactions submitted from Layer-2. We have noticed some recent attempts, such as bitVM, which are considering bringing Bitcoin the ability to leverage existing scripts to verify off-chain transactions (EVM). Therefore, out of rigor, we tend to conclude that &quot;Bitcoin&#x27;s current scripts are unable to natively verify general purpose computation from Layer-1 with feasibility from an engineering point of view,&quot; rather than making absolute judgments, such as &quot;Bitcoin will never have such capabilities in the future.&quot;</p>
<p>Long story short, ZK demonstrates some great advantages to meet the essential requirements of a Bitcoin Layer-2. First, the limitations of Bitcoin&#x27;s scripting capabilities make non-ZK Layer-2 solutions extremely unfriendly to operators and verifiers. Second, the core advantages of ZK, such as succinctness, verification resource friendliness, and privacy-preserving, make ZK proofs easily verifiable by any third party, providing us with a lot of flexibility and space for customization in the design. In the long run, these key features of ZK will serve Layer-2s better with more potential breakthroughs.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="100-zk-features">100% ZK Features<a href="#100-zk-features" class="hash-link" aria-label="Direct link to 100% ZK Features" title="Direct link to 100% ZK Features">​</a></h3>
<p>As the name suggests, bitcoinZK is strongly committed to ZK properties. Specifically, we aim to achieve 100% ZK provability and 100% ZK verifiability.</p>
<p><strong>100% ZK provability</strong> means that all actions occurring on Layer-2, including all Layer-2 executed ones and asset bridging operations between Layer-1 and Layer-2, will be able to generate ZK Proofs for their validity.</p>
<p>Since Bitcoin miners cannot directly verify the validity of Layer-2 Txs, any smart contract-style Bitcoin Layer-2 cannot inherit the powerful Bitcoin PoW consensus, unless we only resort to Bitcoin&#x27;s existing scripts to build Layer-2 capabilities. Based on this fact, we believe that constructing ZK Proofs for all user actions on Layer-2, combined with a robust and trusted verification mechanism for their state finality, is the best way to ensure the security of a Bitcoin Layer-2.</p>
<p><strong>100% ZK verifiability</strong> refers to the property that all ZK Proofs generated on Layer-2 can be verified by any third party. The challenge for BitcoinZK lies in how we can manage the verification process in a more trustless way.</p>
<ul>
<li>
<p>BitcoinZK avoids introducing Client-side Verification (CSV) schemes, unless necessary. The bad thing about CSV is that it introduces new trust assumptions and some extent of permission, which weakens the trust and decentralization level of the Layer-2 network.</p>
</li>
<li>
<p>BitcoinZK introduces trusted data availability (DA) layers for all Layer-2 Txs and Proofs data</p>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bitvm-framework"><strong>BitVM framework</strong><a href="#bitvm-framework" class="hash-link" aria-label="Direct link to bitvm-framework" title="Direct link to bitvm-framework">​</a></h2>
<p>BitVM is an innovative computational paradigm for Bitcoin, proposed by Robin Linus, designed to enable <strong>Turing-complete computation verification</strong> without requiring changes to Bitcoin’s consensus rules. Unlike Bitcoin Script, which is traditionally limited to simple payment and conditional logic, BitVM achieves complex computation verification by decomposing computations into logic gates (e.g., NAND gates), effectively simulating arbitrary computations within Bitcoin’s framework. The core concept of BitVM is “optimistic verification,” where the majority of computations are performed off-chain, and on-chain verification is triggered only in the case of disputes through a fraud-proof mechanism. </p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="on-chain-verification">On-chain verification<a href="#on-chain-verification" class="hash-link" aria-label="Direct link to On-chain verification" title="Direct link to On-chain verification">​</a></h3>
<p>BitVM serves as the cornerstone of the on-chain verification framework, acting as a critical bridge between ZK computation and the security of the Bitcoin mainnet. BitVM provides a mechanism for on-chain verification, ensuring that smart contract execution results are trustworthy when settled on the Bitcoin mainnet. </p>
<ul>
<li>
<p>BitcoinZK executes smart contracts (e.g., DeFi protocols written in Solidity) off-chain using Prover nodes, which generate state transitions  S→S′ and Zero-Knowledge Proofs (ZK Proofs). </p>
</li>
<li>
<p>Submit ZK proofs and state roots to the Bitcoin mainnet via Taproot scripts</p>
</li>
<li>
<p>BitVM’s logic gate circuit verification ensures the correctness of the computations. Specifically, BitVM decomposes the smart contract’s execution logic into a sequence of Boolean operations, encoded as a Merkle tree within Taproot’s MAST structure. </p>
</li>
<li>
<p>The verification process checks the consistency of sub-circuits <code>T_i</code> with inputs ( x ) and outputs ( y ), formalized as <code>\text{Verify}(T_i, x, y)</code></p>
</li>
<li>
<p>If the results are invalid, a Verifier can initiate an on-chain challenge, ensuring the integrity of BitcoinVM’s state transitions.</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="optimizations-in-bitcoinzk">Optimizations in BitcoinZK<a href="#optimizations-in-bitcoinzk" class="hash-link" aria-label="Direct link to Optimizations in BitcoinZK" title="Direct link to Optimizations in BitcoinZK">​</a></h3>
<p>To optimize performance, BitcoinZK enhances BitVM with several improvements. Precompiled circuits for common EVM operations (e.g., ADD, MUL) reduce the computational overhead of both off-chain execution and on-chain verification. Parallel verification, enabled by Taproot’s MAST structure, allows multiple sub-circuits to be verified simultaneously. Additionally, integrating recursive ZK-SNARKs enables BitcoinZK to aggregate proofs for multiple transaction batches, reducing on-chain data from 10 KB to 1 KB. These optimizations ensure that BitcoinZK can handle high-throughput scenarios efficiently while maintaining low costs.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="pseudo-code-implementation">Pseudo-Code Implementation<a href="#pseudo-code-implementation" class="hash-link" aria-label="Direct link to Pseudo-Code Implementation" title="Direct link to Pseudo-Code Implementation">​</a></h3>
<p>Below is a pseudo-code example that represents how a precompiled ADD circuit might be implemented and verified in BitcoinZKa </p>
<div class="language-plain text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plain codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// Pseudo-code for Precompiled ADD Circuit in BitcoinZK/BitVM</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// Define the circuit structure (Bristol format translated to BitVM logic)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">circuit ADD_Circuit {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    input a[256];    // 256-bit input a</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    input b[256];    // 256-bit input b</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    output sum[256]; // 256-bit sum output</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    output carry;    // Carry-out bit</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // Precompiled logic gate sequence for 1-bit addition (repeated 256 times)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for i = 0 to 255 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        wire a_inv[i] = NOT(a[i]);          // Invert a[i]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        wire and_ab[i] = AND(a[i], b[i]);   // a[i] AND b[i]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        wire and_a_inv_b[i] = AND(a_inv[i], b[i]); // NOT(a[i]) AND b[i]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        sum[i] = XOR(and_ab[i], and_a_inv_b[i]); // Sum bit = XOR of AND results</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (i &lt; 255) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            carry = OR(and_ab[i], and_a_inv_b[i]); // Carry for next bit</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // Precompile the circuit into a standardized BitVM-friendly format</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    precompile() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Optimize gate sequence into Merkle tree for Taproot MAST</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        MerkleRoot = hash(MerkleTree(gate_sequence));</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return MerkleRoot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // Generate ZK Proof for off-chain execution</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    generateProof(inputs: [a, b]) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        state = executeCircuit(inputs);       // Off-chain execution</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        proof = zkProve(state, MerkleRoot);   // Generate ZK Proof</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return proof;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// BitVM Verification on Bitcoin Mainnet (Taproot Script)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">verifyProof(proof, MerkleRoot, state) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (zkVerify(proof, MerkleRoot, state)) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Valid proof, update BitcoinZK state on mainnet</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        updateState(state);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Trigger BitVM fraud proof for dispute</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        revealSubCircuit(proof, MerkleRoot);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (verifySubCircuit()) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            penalizeProver();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// Usage in BitcoinZK</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    inputs = [0x1234..., 0x5678...]; // Example 256-bit inputs a and b</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    circuit = new ADD_Circuit();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    MerkleRoot = circuit.precompile();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    proof = circuit.generateProof(inputs);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    verifyProof(proof, MerkleRoot, computeState(inputs)); // Settle on Bitcoin mainnet</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>Explanation</strong>:</p>
<ul>
<li>
<p><strong>Circuit Definition</strong>: The ADD_Circuit defines a 256-bit adder using basic gates (NOT, AND, XOR, OR). For simplicity, this example shows a single-bit slice, repeated 256 times for a full 256-bit addition with carry propagation.</p>
</li>
<li>
<p><strong>Precompilation</strong>: The precompile() function optimizes the gate sequence into a Merkle tree, stored in Taproot’s MAST structure, reducing on-chain data to a fixed-size root (≈1 KB).</p>
</li>
<li>
<p><strong>ZK Proof Generation</strong>: The generateProof() method executes the circuit off-chain and generates a ZK Proof (e.g., using ZK-SNARK), which BitVM verifies on-chain.</p>
</li>
<li>
<p><strong>Verification</strong>: The verifyProof() function uses Taproot scripts to validate the proof on the Bitcoin mainnet. If invalid, BitVM’s fraud-proof mechanism reveals the faulty sub-circuit for resolution.</p>
</li>
<li>
<p><strong>Usage</strong>: In BitcoinZK, this precompiled circuit is used to efficiently compute additions (e.g., in DeFi smart contracts), settling the result on Bitcoin’s PoW consensus layer.</p>
</li>
</ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/About BitcoinZK/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">About BitcoinZK</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/About BitcoinZK/BitcoinZK Architecture"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">BitcoinZK Architecture</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#zero-knowledge" class="table-of-contents__link toc-highlight">Zero-knowledge</a><ul><li><a href="#what-and-why" class="table-of-contents__link toc-highlight">What and Why</a></li><li><a href="#100-zk-features" class="table-of-contents__link toc-highlight">100% ZK Features</a></li></ul></li><li><a href="#bitvm-framework" class="table-of-contents__link toc-highlight"><strong>BitVM framework</strong></a><ul><li><a href="#on-chain-verification" class="table-of-contents__link toc-highlight">On-chain verification</a></li><li><a href="#optimizations-in-bitcoinzk" class="table-of-contents__link toc-highlight">Optimizations in BitcoinZK</a></li><li><a href="#pseudo-code-implementation" class="table-of-contents__link toc-highlight">Pseudo-Code Implementation</a></li></ul></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>